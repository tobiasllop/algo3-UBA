# Práctica 1

### Ejercicio 3
Se nos dice que la matriz es simetrica por lo que primero la completaremos:

$$
\begin{pmatrix}
 0 & 10 & 10 & 1 \\
 10 & 0 & 5 & 2 \\
 10 & 5 & 0 & 1 \\
 1 & 2 & 1 & 0 \\
\end{pmatrix}
$$

#### a.

     def max_subset_sum(M, n, k, i=0, curr_sum=0, curr_subset=[]):
         # Caso base: si ya tenemos k elementos en curr_subset
         if len(curr_subset) == k:
             return curr_sum
     
         # Si ya no quedan más elementos que agregar
         if i == n:
             return 0
     
         # Caso 1: No agregar el elemento i al subconjunto
         omit = max_subset_sum(M, n, k, i+1, curr_sum, curr_subset)
     
         # Caso 2: Agregar el elemento i al subconjunto
         curr_subset.append(i)
         subset_sum = curr_sum
         for j in curr_subset:
             subset_sum += M[i][j] + M[j][i]
         include = max_subset_sum(M, n, k, i+1, subset_sum, curr_subset)
         curr_subset.pop()
     
         # Devolver el máximo de los dos casos
         return max(omit, include)
 
     # Función principal
     def max_subset_matrix_sum(M, k):
         n = len(M)
         return max_subset_sum(M, n, k)
             
#### b.
La complejidad temporal de este algoritmo es O(n * 2^n), ya que en cada nivel del árbol de recursión hay n posibles elementos para agregar al subconjunto, y hay un total de 2^n subconjuntos posibles.
